using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Drawing.Drawing2D;

namespace Lightspeed
{
    /// <summary>
    /// Contains tools for working with Lilypond to make flashcards.  Most of this stuff requires that you have Lilypond installed somewhere.
    /// </summary>
    public static class LilypondUtils
    {
        /// <summary>
        /// For a given flashcard, make a lilypond-compatible string that can be
        /// used to render the flashcard.
        /// </summary>
        /// <param name="flashcard">The flashcard to render.</param>
        /// <returns>A lilypond script.</returns>
        public static string MakeLilypondScript(Flashcard flashcard)
        {
            var leftHandNotes = flashcard.StaffNotes
                .Where(sn => sn.Staff == Staff.LeftHand)
                .OrderBy(sn => sn.NoteRepresentation.Note.Number)
                .Select(sn => ConvertStaffNoteToLilypondNote(sn))
                .ToArray();
            string leftHandString;
            if (leftHandNotes.Any())
                leftHandString = String.Format("<{0}>", String.Join(" ", leftHandNotes));
            else
                leftHandString = "r4";

            var rightHandNotes = flashcard.StaffNotes
                .Where(sn => sn.Staff == Staff.RightHand)
                .OrderBy(sn => sn.NoteRepresentation.Note.Number)
                .Select(sn => ConvertStaffNoteToLilypondNote(sn))
                .ToArray();
            string rightHandString;
            if (rightHandNotes.Any())
                rightHandString = String.Format("<{0}>", String.Join(" ", rightHandNotes));
            else
                rightHandString = "r4";

            return String.Format(LP_FORMAT, rightHandString, leftHandString);
        }

        /// <summary>
        /// Turn all possible flashcards into image files on disk.  Takes a while.
        /// </summary>
        /// <param name="pathToLilypond">Full path to lilypond.exe.</param>
        /// <param name="outputFolder">Files will be written here.</param>
        public static void RenderAllNotes(string pathToLilypond, string outputFolder)
        {
            if (!File.Exists(pathToLilypond))
                throw new ArgumentException("pathToLilypond was not found.");

            // check for, create working folder.
            if (!Directory.Exists(outputFolder))
                throw new ArgumentException("outputFolder does not exist.");

            var workingFolder = Path.Combine(outputFolder, "working");
            if (!Directory.Exists(workingFolder))
                Directory.CreateDirectory(workingFolder);
            
            // write all LY files to working.
            var generator = new MultipleFlashcardGenerator(
                new SingleNoteFlashcardGenerator(),
                new IntervalFlashcardGenerator(),
                new TriadFlashcardGenerator());
            var filePaths = new List<string>();
            
            foreach (var flashcard in generator.GenerateFlashcards().Take(5))
            {
                var script = MakeLilypondScript(flashcard);
                var fileName = flashcard.MakeUniqueString() + ".ly";
                var filePath = Path.Combine(workingFolder, fileName);
                File.WriteAllText(filePath, script);
                filePaths.Add(filePath);                
            }

            // execute lilypond on all files to outputFolder.
            // chunking is used here: it's good to render lots of LY files at once to lilypond doesn't start up too
            // many times (which is very slow) but there's a limit to how many command line filename parameters you can pass in.
            var chunkSize = 100;
            var processed = 0;
            List<string> chunk = new List<string>(chunkSize);
            
            while (processed < filePaths.Count)
            {
                chunk.Clear();
                int chunkStartIndex = processed;
                int chunkEndIndex = Math.Min(processed + chunkSize, filePaths.Count);
                for (int i = chunkStartIndex; i < chunkEndIndex; i++)
                    chunk.Add(filePaths[i]);

                var fileList = String.Join("\" \"", chunk.ToArray());
                var arguments = String.Format("--format=pdf --output=\"{0}\" \"{1}\"", outputFolder, fileList);
                var process = new Process();
                process.StartInfo.FileName = pathToLilypond;
                process.StartInfo.Arguments = arguments;
                process.Start();
                process.WaitForExit();
                processed += chunk.Count;
            }

            // delete all the PS files that were generated by the process, and the working folder.
            Directory.Delete(workingFolder, true);
            foreach (var workingFile in new DirectoryInfo(outputFolder).GetFiles("*.ps"))
                workingFile.Delete();

            int croppedWidth = 100;
            int croppedHeight = 175;
            int cropLeft = 81;
            int cropTop = 30;
            
            // crop all of the PNGs that were generated.
            foreach (var bigPng in new DirectoryInfo(outputFolder).GetFiles("*.png"))
            {
                var cropped = CropImageFile(File.ReadAllBytes(bigPng.FullName), croppedWidth, croppedHeight, cropLeft, cropTop);
                File.WriteAllBytes(bigPng.FullName, cropped);
            }            
        }        

        const string LP_FORMAT = @"\score {{
<<
  \new Staff {{
    \clef treble
        {0}
  }}

  \new Staff{{
    \clef bass
        {1}
  }}
>>
  \layout {{
    ragged-right = ##t
    \context {{
      \Staff
      \remove ""Time_signature_engraver""
      \remove ""Bar_engraver""
    }}
  }}
}}";

        /// <summary>
        /// Given a staffnote, generate a single-note representation in lilypond.
        /// </summary>
        internal static string ConvertStaffNoteToLilypondNote(StaffNote sf)
        {
            if (sf.NoteRepresentation.Note.Number < 1 || sf.NoteRepresentation.Note.Number > 88)
                throw new ArgumentException("Unsupported note number.");

            // there's probably an algorithm for this, but it's quicker to just type it for now...
            string noteName = sf.NoteRepresentation.Name.ToString().ToLower();
            string accidental =
                sf.NoteRepresentation.Accidental == AccidentalType.Natural ? "" : 
                sf.NoteRepresentation.Accidental == AccidentalType.Sharp ? "is" :
                "es";
            string octaveModifier =
                sf.NoteRepresentation.Note.Number < 4 ? ",,," :
                sf.NoteRepresentation.Note.Number < 16 ? ",," :
                sf.NoteRepresentation.Note.Number < 28 ? "," :
                sf.NoteRepresentation.Note.Number < 40 ? "" :
                sf.NoteRepresentation.Note.Number < 52 ? "'" :
                sf.NoteRepresentation.Note.Number < 64 ? "''" :
                sf.NoteRepresentation.Note.Number < 76 ? "'''" :
                sf.NoteRepresentation.Note.Number < 88 ? "''''" :
                "'''''"; // only the top C gets this!
                        
            return string.Format("{0}{1}{2}", noteName, accidental, octaveModifier);
        }

        /// <summary>
        /// I'm no expert in this stuff, this came from an online code snippet and I've only touched it up a bit.  Seems to work.
        /// </summary>
        static byte[] CropImageFile(byte[] imageBytes, int targetW, int targetH, int targetX, int targetY)
        {
            using (var img = Image.FromStream(new MemoryStream(imageBytes)))
            {
                using (var bitmap = new Bitmap(targetW, targetH, PixelFormat.Format24bppRgb))
                {
                    bitmap.SetResolution(72, 72);

                    using (var graphics = Graphics.FromImage(bitmap))
                    {
                        graphics.SmoothingMode = SmoothingMode.AntiAlias;
                        graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                        graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;
                        graphics.DrawImage(img, new Rectangle(0, 0, targetW, targetH), targetX, targetY, targetW, targetH, GraphicsUnit.Pixel);
                        MemoryStream ms = new MemoryStream();
                        bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                        return ms.GetBuffer();
                    }
                }
            }
        }
    }
}
